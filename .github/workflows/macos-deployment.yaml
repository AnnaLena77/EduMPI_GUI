name: macOS Deployment

env:
  QT_VERSION: 6.8.1
  APP_NAME: appGUI_Cluster
  BUILD_DIR: build
  INSTALL_DIR: appdir

on:
  push:
    branches:
      - native

jobs:
  deploy:
    runs-on: macos-14
    timeout-minutes: 35

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Install Qt
        uses: jurplel/install-qt-action@v4
        with:
          version: ${{ env.QT_VERSION }}
          host: mac
          target: desktop
          arch: clang_64
          modules: qtquick3d qtshadertools
          tools: tools_cmake
          cache: true

      - name: Install build dependencies
        timeout-minutes: 10
        run: |
          set -e
          # brew update ist in CI oft langsam/buggy -> weglassen oder "best effort"
          brew update || true
          brew install ninja cmake libpq
          echo "$(brew --prefix libpq)/bin" >> $GITHUB_PATH
          echo "PostgreSQL_ROOT=$(brew --prefix libpq)" >> $GITHUB_ENV
          echo "PKG_CONFIG_PATH=$(brew --prefix libpq)/lib/pkgconfig" >> $GITHUB_ENV
          echo "HOMEBREW_PREFIX=$(brew --prefix)" >> $GITHUB_ENV

          echo "libpq files:"
          ls -la "$(brew --prefix libpq)/lib/"libpq* || true

      - name: Configure (CMake)
        timeout-minutes: 10
        run: |
          set -e
          cmake -S . -B "${BUILD_DIR}" -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DPostgreSQL_ROOT="${PostgreSQL_ROOT}" \
            -DPostgreSQL_INCLUDE_DIR="${PostgreSQL_ROOT}/include" \
            -DPostgreSQL_LIBRARY="${PostgreSQL_ROOT}/lib/libpq.dylib"

      - name: Build
        timeout-minutes: 15
        run: |
          set -e
          cmake --build "${BUILD_DIR}" --config Release

      - name: Install into staging dir (optional, recommended)
        timeout-minutes: 10
        run: |
          set -e
          cmake --install "${BUILD_DIR}" --prefix "${INSTALL_DIR}"

      - name: Locate .app
        id: locate
        run: |
          set -e
          if [ -d "${INSTALL_DIR}/${APP_NAME}.app" ]; then
            echo "APP_PATH=${INSTALL_DIR}/${APP_NAME}.app" >> $GITHUB_OUTPUT
            exit 0
          fi
          if [ -d "${BUILD_DIR}/${APP_NAME}.app" ]; then
            echo "APP_PATH=${BUILD_DIR}/${APP_NAME}.app" >> $GITHUB_OUTPUT
            exit 0
          fi
          FOUND=$(find . -maxdepth 4 -name "${APP_NAME}.app" -type d | head -n 1)
          if [ -n "$FOUND" ]; then
            echo "APP_PATH=$FOUND" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "Could not find ${APP_NAME}.app"; exit 1

      - name: macdeployqt (bundle Qt frameworks/plugins)
        timeout-minutes: 10
        run: |
          set -e
          APP="${{ steps.locate.outputs.APP_PATH }}"
          echo "Using app: $APP"
          macdeployqt "$APP" -qmldir=. -verbose=2

      - name: Ensure QPSQL driver is bundled (no risky find)
        timeout-minutes: 5
        run: |
          set -e
          APP="${{ steps.locate.outputs.APP_PATH }}"
          PLUGDIR="$APP/Contents/PlugIns/sqldrivers"
          mkdir -p "$PLUGDIR"

          if [ -f "$PLUGDIR/libqsqlpsql.dylib" ]; then
            echo "QPSQL already bundled."
            ls -la "$PLUGDIR"
            exit 0
          fi

          # Robust: plugin dir über qtpaths6
          if ! command -v qtpaths6 >/dev/null 2>&1; then
            echo "qtpaths6 not found; cannot locate Qt plugin dir."; exit 1
          fi

          QTPLUGDIR="$(qtpaths6 --plugin-dir)"
          echo "Qt plugin dir: $QTPLUGDIR"

          SRC="$QTPLUGDIR/sqldrivers/libqsqlpsql.dylib"
          if [ ! -f "$SRC" ]; then
            echo "libqsqlpsql.dylib not found at: $SRC"; exit 1
          fi

          cp "$SRC" "$PLUGDIR/"
          echo "Bundled sqldrivers:"
          ls -la "$PLUGDIR"

      # >>> WICHTIG: Hier ohne dylibbundler. Stattdessen explizit libpq + deps kopieren und Pfade fixen.
      - name: Bundle libpq and fix linkage (deterministic, no loops)
        timeout-minutes: 10
        run: |
          set -e
          APP="${{ steps.locate.outputs.APP_PATH }}"
          EXE="$APP/Contents/MacOS/${APP_NAME}"
          PLUGIN="$APP/Contents/PlugIns/sqldrivers/libqsqlpsql.dylib"

          if [ ! -f "$EXE" ]; then
            echo "Executable not found at $EXE"
            ls -la "$APP/Contents/MacOS" || true
            exit 1
          fi
          if [ ! -f "$PLUGIN" ]; then
            echo "QPSQL plugin not found at $PLUGIN"
            ls -la "$APP/Contents/PlugIns/sqldrivers" || true
            exit 1
          fi

          DEST="$APP/Contents/Frameworks"
          mkdir -p "$DEST"

          LIBPQ_PREFIX="$(brew --prefix libpq)"
          echo "libpq prefix: $LIBPQ_PREFIX"

          # 1) libpq selbst ins Bundle kopieren (alle Varianten)
          cp -av "$LIBPQ_PREFIX/lib/"libpq*.dylib "$DEST/" || true
          echo "Frameworks after libpq copy:"
          ls -la "$DEST" || true

          # 2) Abhängigkeiten von libpq ebenfalls kopieren (nur non-system, aus /opt/homebrew oder /usr/local)
          #    (SSL/crypto etc. hängen oft dran.)
          for L in "$DEST"/libpq*.dylib; do
            [ -f "$L" ] || continue
            echo "Deps for $L"
            otool -L "$L" | awk 'NR>1 {print $1}' | while read -r dep; do
              case "$dep" in
                /System/*|/usr/lib/*) ;;
                *)
                  if [ -f "$dep" ]; then
                    echo "  copying dep: $dep"
                    cp -av "$dep" "$DEST/" || true
                  else
                    echo "  dep not found on runner: $dep"
                  fi
                ;;
              esac
            done
          done

          echo "Frameworks after deps copy:"
          ls -la "$DEST" || true

          # 3) install_name_tool: IDs setzen + Referenzen umschreiben auf @executable_path/../Frameworks
          for f in "$DEST"/*.dylib; do
            [ -f "$f" ] || continue
            base="$(basename "$f")"
            install_name_tool -id "@executable_path/../Frameworks/$base" "$f" || true
          done

          # Rewrite in plugin + exe: alle Homebrew deps -> Bundle
          rewrite() {
            local target="$1"
            echo "Rewriting deps in: $target"
            otool -L "$target" | awk 'NR>1 {print $1}' | while read -r dep; do
              case "$dep" in
                /System/*|/usr/lib/*) ;;
                *)
                  base="$(basename "$dep")"
                  if [ -f "$DEST/$base" ]; then
                    install_name_tool -change "$dep" "@executable_path/../Frameworks/$base" "$target" || true
                  fi
                ;;
              esac
            done
          }

          rewrite "$PLUGIN"
          rewrite "$EXE"

          echo "Final linkage (plugin):"
          otool -L "$PLUGIN" || true

          echo "Final linkage (exe):"
          otool -L "$EXE" || true

      - name: Create DMG
        timeout-minutes: 10
        run: |
          set -e
          APP="${{ steps.locate.outputs.APP_PATH }}"
          OUTDIR=dist
          mkdir -p "$OUTDIR"

          macdeployqt "$APP" -dmg -verbose=2

          DMG="$(dirname "$APP")/${APP_NAME}.dmg"
          if [ ! -f "$DMG" ]; then
            DMG="$(find . -maxdepth 5 -name "${APP_NAME}.dmg" | head -n 1 || true)"
          fi
          if [ -z "$DMG" ] || [ ! -f "$DMG" ]; then
            echo "DMG not found"; exit 1
          fi

          mv "$DMG" "$OUTDIR/"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-macos
          path: dist/${{ env.APP_NAME }}.dmg
