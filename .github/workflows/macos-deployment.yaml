name: macOS Deployment

env:
  QT_VERSION: 6.8.1
  APP_NAME: appGUI_Cluster
  BUILD_DIR: build
  INSTALL_DIR: appdir

on:
  push:
    branches:
      - native

jobs:
  deploy:
    runs-on: macos-14

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Install Qt
        uses: jurplel/install-qt-action@v4
        with:
          version: ${{ env.QT_VERSION }}
          host: mac
          target: desktop
          arch: clang_64
          modules: qtquick3d qtshadertools
          tools: tools_cmake
          cache: true

      - name: Install build dependencies
        run: |
          brew update
          brew install ninja cmake
          # Falls du libpq zur Laufzeit brauchst (PostgreSQL client library):
          brew install postgresql@16
          echo "$(brew --prefix postgresql@16)/bin" >> $GITHUB_PATH
        
      - name: Install PostgreSQL client (libpq)
        run: |
          brew update
          brew install libpq
          # libpq ist keg-only -> Pfade explizit setzen:
          echo "$(brew --prefix libpq)/bin" >> $GITHUB_PATH
          echo "PostgreSQL_ROOT=$(brew --prefix libpq)" >> $GITHUB_ENV
          echo "PKG_CONFIG_PATH=$(brew --prefix libpq)/lib/pkgconfig" >> $GITHUB_ENV


      - name: Configure (CMake)
        run: |
          cmake -S . -B "${BUILD_DIR}" -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DPostgreSQL_ROOT="${PostgreSQL_ROOT}" \
            -DPostgreSQL_INCLUDE_DIR="${PostgreSQL_ROOT}/include" \
            -DPostgreSQL_LIBRARY="${PostgreSQL_ROOT}/lib/libpq.dylib"


      - name: Build
        run: |
          cmake --build "${BUILD_DIR}" --config Release

      # Optional aber sehr hilfreich: "install" Target nutzen, um eine saubere App-Struktur zu bekommen.
      # Voraussetzung: Dein CMakeLists.txt definiert install(TARGETS ...) usw.
      - name: Install into staging dir (optional, recommended)
        run: |
          cmake --install "${BUILD_DIR}" --prefix "${INSTALL_DIR}"

      # Wenn du KEIN CMake install() hast, musst du stattdessen deine .app aus dem Build holen:
      # z.B. cp -R build/${APP_NAME}.app appdir/

      - name: Locate .app
        id: locate
        run: |
          set -e
          # 1) bevorzugt aus install dir
          if [ -d "${INSTALL_DIR}/${APP_NAME}.app" ]; then
            echo "APP_PATH=${INSTALL_DIR}/${APP_NAME}.app" >> $GITHUB_OUTPUT
            exit 0
          fi
          # 2) fallback: direkt im build (passe ggf. Pfad an)
          if [ -d "${BUILD_DIR}/${APP_NAME}.app" ]; then
            echo "APP_PATH=${BUILD_DIR}/${APP_NAME}.app" >> $GITHUB_OUTPUT
            exit 0
          fi
          # 3) Suche als letzter Ausweg
          FOUND=$(find . -maxdepth 4 -name "${APP_NAME}.app" -type d | head -n 1)
          if [ -n "$FOUND" ]; then
            echo "APP_PATH=$FOUND" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "Could not find ${APP_NAME}.app"; exit 1

      - name: macdeployqt (bundle Qt frameworks/plugins)
        run: |
          set -e
          APP="${{ steps.locate.outputs.APP_PATH }}"
          echo "Using app: $APP"
          # macdeployqt liegt im Qt bin dir; install-qt-action setzt PATH normalerweise passend.
          macdeployqt "$APP" -qmldir=. -verbose=2

      # PostgreSQL / QPSQL Hinweis:
      # Wenn du QtSql mit PostgreSQL nutzt, brauchst du das Plugin "qsqlpsql".
      # macdeployqt nimmt sqldrivers manchmal mit, manchmal nicht (abhängig davon, ob es erkannt wird).
      # Daher hier eine harte Prüfung + ggf. Nachziehen.
      - name: Ensure QPSQL driver is bundled
        run: |
          set -e
          APP="${{ steps.locate.outputs.APP_PATH }}"
          PLUGDIR="$APP/Contents/PlugIns/sqldrivers"
          mkdir -p "$PLUGDIR"

          # Prüfen, ob qsqlpsql drin ist:
          if ls "$PLUGDIR"/libqsqlpsql.dylib >/dev/null 2>&1; then
            echo "QPSQL driver already bundled."
          else
            echo "QPSQL not found in app bundle; trying to locate in Qt installation..."
            # Suche in Qt-Installationspfaden:
            QSQLPSQL=$(find "$Qt6_DIR" "$Qt_DIR" "$HOME" -path "*plugins/sqldrivers/libqsqlpsql.dylib" 2>/dev/null | head -n 1 || true)
            if [ -z "$QSQLPSQL" ]; then
              echo "Could not locate libqsqlpsql.dylib. Make sure QtSql + PostgreSQL driver are available in your Qt install."
              exit 1
            fi
            cp "$QSQLPSQL" "$PLUGDIR/"
          fi

          echo "Bundled sqldrivers:"
          ls -la "$PLUGDIR"

      # Optional: falls libpq dynamisch genutzt wird (häufig), musst du libpq mit in die App nehmen.
      # Das hängt davon ab, wie du linkst. Mit otool siehst du, ob libpq fehlt.
      - name: Check dynamic libraries (quick sanity)
        run: |
          set -e
          APP="${{ steps.locate.outputs.APP_PATH }}"
          BIN="$APP/Contents/MacOS/${APP_NAME}"
          if [ -f "$BIN" ]; then
            echo "otool -L:"
            otool -L "$BIN" || true
          else
            echo "Binary not found at $BIN (maybe different executable name inside .app)."
          fi

      - name: Create DMG
        run: |
          set -e
          APP="${{ steps.locate.outputs.APP_PATH }}"
          OUTDIR=dist
          mkdir -p "$OUTDIR"
          # macdeployqt kann DMG bauen, wenn du es auf die .app anwendest:
          macdeployqt "$APP" -dmg -verbose=2
          # Das DMG landet i.d.R. neben der .app. Wir verschieben es nach dist:
          DMG=$(dirname "$APP")/${APP_NAME}.dmg
          if [ ! -f "$DMG" ]; then
            # fallback: irgendwo suchen
            DMG=$(find . -maxdepth 4 -name "${APP_NAME}.dmg" | head -n 1 || true)
          fi
          if [ -z "$DMG" ] || [ ! -f "$DMG" ]; then
            echo "DMG not found"; exit 1
          fi
          mv "$DMG" "$OUTDIR/"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-macos
          path: dist/${{ env.APP_NAME }}.dmg


